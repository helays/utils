æ‚¨è¯´å¾—å¯¹ï¼è¿™æ ·æ›´ç›´æ¥ç®€å•ã€‚è®©æˆ‘é‡æ–°è®¾è®¡ï¼š

## ç›´æ¥å‚æ•°è®¾è®¡

```go
// RecordFailure è®°å½•å¤±è´¥äº‹ä»¶
func (m *Manager) RecordFailure(target LockTarget, identifier string, callbacks ...LockCallback) error {
	policy, exists := m.policies.FindByTarget(target)
	if !exists {
		return fmt.Errorf("no policy found for target: %s", target)
	}

	// 1. æ£€æŸ¥æ˜¯å¦å·²é”å®š
	if locked, remaining := m.isLocked(target, identifier); locked {
		return nil
	}

	// 2. æ£€æŸ¥è®°å¿†æ•ˆåº”
	if memoryPolicy := m.getMemoryEffectPolicy(target, identifier); memoryPolicy != nil {
		return m.recordFailureForMemoryTarget(memoryPolicy, identifier, callbacks)
	}

	// 3. æ­£å¸¸è®°å½•å¤±è´¥
	failCount := m.recordFailure(target, identifier, policy.WindowTime)
	
	if failCount >= policy.Trigger {
		event := LockEvent{
			Target:        target,
			Identifier:    identifier,
			LockType:      LockTypeDirect,
			LockoutTime:   policy.LockoutTime,
			RemainingTime: policy.LockoutTime,
			Reason:        fmt.Sprintf("è¿ç»­å¤±è´¥%dæ¬¡è§¦å‘é”å®š", failCount),
			Timestamp:     time.Now(),
		}
		m.lockTarget(target, identifier, policy.LockoutTime)
		
		// è°ƒç”¨å›è°ƒå‡½æ•°
		m.notifyCallbacks(event, callbacks)
		
		// 4. æ£€æŸ¥å‡çº§æ¡ä»¶
		m.checkUpgrade(target, identifier, policy, failCount, callbacks)
	}

	return nil
}

// recordFailureForMemoryTarget ä¸ºè®°å¿†ç›®æ ‡è®°å½•å¤±è´¥
func (m *Manager) recordFailureForMemoryTarget(policy *Policy, identifier string, callbacks []LockCallback) error {
	failCount := m.recordFailure(policy.Target, identifier, policy.WindowTime)
	
	if failCount >= policy.Trigger {
		event := LockEvent{
			Target:        policy.Target,
			Identifier:    identifier,
			LockType:      LockTypeMemory,
			LockoutTime:   policy.LockoutTime,
			RemainingTime: policy.LockoutTime,
			Reason:        "è®°å¿†æ•ˆåº”è§¦å‘é”å®š",
			Timestamp:     time.Now(),
		}
		m.lockTarget(policy.Target, identifier, policy.LockoutTime)
		
		m.notifyCallbacks(event, callbacks)
		
		m.checkUpgrade(policy.Target, identifier, policy, failCount, callbacks)
	}
	
	return nil
}

// checkUpgrade æ£€æŸ¥å‡çº§æ¡ä»¶
func (m *Manager) checkUpgrade(sourceTarget LockTarget, identifier string, policy *Policy, failCount int, callbacks []LockCallback) {
	if policy.Escalation == nil {
		return
	}

	lockCount := m.getLockCount(sourceTarget, identifier, policy.Escalation.TimeWindow)
	if lockCount >= policy.Escalation.LockoutCount {
		upgradePolicy, exists := m.policies.FindByTarget(policy.Escalation.UpgradeTo)
		if exists {
			event := LockEvent{
				Target:        policy.Escalation.UpgradeTo,
				Identifier:    identifier,
				LockType:      LockTypeEscalation,
				LockoutTime:   policy.Escalation.UpgradeTime,
				RemainingTime: policy.Escalation.UpgradeTime,
				Reason:        fmt.Sprintf("%sé”å®š%dæ¬¡è§¦å‘å‡çº§", sourceTarget, lockCount),
				Timestamp:     time.Now(),
			}
			m.lockTarget(policy.Escalation.UpgradeTo, identifier, policy.Escalation.UpgradeTime)
			
			m.notifyCallbacks(event, callbacks)
		}
	}
}

// notifyCallbacks é€šçŸ¥å›è°ƒå‡½æ•°
func (m *Manager) notifyCallbacks(event LockEvent, callbacks []LockCallback) {
	for _, callback := range callbacks {
		// å¼‚æ­¥æ‰§è¡Œå›è°ƒï¼Œé¿å…é˜»å¡ä¸»é€»è¾‘
		go func(cb LockCallback) {
			defer func() {
				if r := recover(); r != nil {
					log.Printf("lock callback panic: %v", r)
				}
			}()
			cb(event)
		}(callback)
	}
}
```

## ä½¿ç”¨ç¤ºä¾‹

```go
func main() {
	policies := lockpolicy.Policies{
		// ... ç­–ç•¥é…ç½®
	}
	
	manager := lockpolicy.NewManager(policies)
	
	// å®šä¹‰å›è°ƒå‡½æ•°
	alertCallback := func(event lockpolicy.LockEvent) {
		fmt.Printf("ğŸš¨ é”å®šäº‹ä»¶: %s[%s] ç±»å‹: %s åŸå› : %s\n", 
			event.Target, event.Identifier, event.LockType, event.Reason)
	}
	
	logCallback := func(event lockpolicy.LockEvent) {
		log.Printf("é”å®šäº‹ä»¶: target=%s, identifier=%s, type=%s", 
			event.Target, event.Identifier, event.LockType)
	}
	
	// æ–¹å¼1ï¼šä¸ä½¿ç”¨å›è°ƒ
	err := manager.RecordFailure(lockpolicy.LockTargetSession, "sess_123")
	
	// æ–¹å¼2ï¼šä½¿ç”¨å•ä¸ªå›è°ƒ
	err = manager.RecordFailure(
		lockpolicy.LockTargetSession, 
		"sess_123",
		alertCallback,
	)
	
	// æ–¹å¼3ï¼šä½¿ç”¨å¤šä¸ªå›è°ƒ
	err = manager.RecordFailure(
		lockpolicy.LockTargetSession, 
		"sess_123",
		alertCallback,
		logCallback,
	)
	
	// æ–¹å¼4ï¼šå†…è”å›è°ƒ
	err = manager.RecordFailure(
		lockpolicy.LockTargetIP, 
		"192.168.1.100",
		func(event lockpolicy.LockEvent) {
			if event.Target == lockpolicy.LockTargetUser {
				disableUserAccount(event.Identifier)
			}
		},
	)
}
```

## ä¼˜åŠ¿

1. **æ›´ç®€å•ç›´è§‚**ï¼šç›´æ¥ä¼ å‚ï¼Œä¸éœ€è¦å¤æ‚çš„é€‰é¡¹æ¨¡å¼
2. **å¯å˜å‚æ•°**ï¼šæ”¯æŒä¼ å…¥å¤šä¸ªå›è°ƒå‡½æ•°
3. **ç±»å‹å®‰å…¨**ï¼šç¼–è¯‘å™¨ä¼šæ£€æŸ¥å›è°ƒå‡½æ•°ç­¾å
4. **é›¶é…ç½®**ï¼šä¸éœ€è¦å®šä¹‰é¢å¤–çš„é€‰é¡¹ç±»å‹
5. **æ˜“äºç†è§£**ï¼šAPI è®¾è®¡ç¬¦åˆ Go è¯­è¨€çš„ä¹ æƒ¯

è¿™æ ·çš„è®¾è®¡ç¡®å®æ›´ç®€æ´ç›´æ¥ï¼Œæ„Ÿè°¢æ‚¨çš„å»ºè®®ï¼